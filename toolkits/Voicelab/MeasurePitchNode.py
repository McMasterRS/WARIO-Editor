from pipeline.Node import Node
from parselmouth.praat import call
from toolkits.Voicelab.VoicelabNode import VoicelabNode

###################################################################################################
# MEASURE PITCH NODE
# WARIO pipeline node for measuring voice pitch.
###################################################################################################
# ARGUMENTS:
# 'voice'   : sound file generated by parselmouth praat
###################################################################################################
# RETURNS:
# 'mean_f0' : mean pitch
# 'stdev_f0': standard deviation
# 'min_f0'  : min pitch value
# 'max_f0'  : max pitch value
###################################################################################################

class MeasurePitchNode(VoicelabNode):

    def __init__(self, *args, **kwargs):

        super().__init__(*args, **kwargs)
        # Default settings for measuring pitch.
        # TODO: Come up with a better system for exposing these settings to the system.
        self.args = {

            # Simple default values
            'Time Step': 0,
            'Max Number of Candidates': 15,
            'Silence Threshold': 0.03,
            'Voicing Threshold': 0.45,
            'Octave Cost': 0.01,
            'Octave Jump Cost': 0.35,
            'Voiced Unvoiced Cost': 0.14,
            'Unit': 'Hertz',

            # Tuple defines a discrete set of options, 0 is selected value, 1 is a list of all options
            'Algorithm': ('To Pitch (ac)', ['To Pitch (ac)', 'To Pitch (cc)']),
            'Very Accurate': ('no', ['yes', 'no']),

            # The default setting is to generate these when processing is done.
            'Ceiling': self.pitch_ceiling,
            'Floor': self.pitch_floor
            
        }

    def process(self):

        voice = self.args['voice']
        file_duration: float = call(voice, "Get total duration")

        pitch = call(
            voice,
            self.args["Algorithm"][0],
            self.args["Time Step"], 
            self.args['Floor'](voice),
            self.args["Max Number of Candidates"],
            self.args["Very Accurate"][0],
            self.args["Silence Threshold"],
            self.args["Voicing Threshold"],
            self.args["Octave Cost"],
            self.args["Octave Jump Cost"],
            self.args["Voiced Unvoiced Cost"],
            self.args['Ceiling'](voice))

        mean_f0: float = call(pitch, "Get mean", 0, 0, self.args['Unit'])
        stdev_f0: float = call(pitch, "Get standard deviation", 0, 0, self.args['Unit'])  # get standard deviation
        min_f0: float = call(pitch, "Get minimum", 0, 0, "hertz", "Parabolic")
        max_f0: float = call(pitch, "Get maximum", 0, 0, "hertz", "Parabolic")

        return {
            'mean_f0': mean_f0,
            'stdev_f0': stdev_f0,
            'min_f0': min_f0,
            'max_f0': max_f0,
            'pitch': pitch
        }

    # Default generation of the pitch ceiling
    def pitch_ceiling(self, voice):
        broad_pitch = call(voice, "To Pitch (cc)", 0, 50, 15, "yes", 0.03, 0.45, 0.01, 0.35, 0.14, 800)
        broad_mean_f0: float = call(broad_pitch, "Get mean", 0, 0, "hertz")  # get mean pitch
        if broad_mean_f0 < 400:
            pitch2 = call(voice, "To Pitch (cc)", 0, 50, 15, "yes", 0.03, 0.45, 0.01, 0.35, 0.14, 500)
            pitch2_max_f0: float = call(pitch2, "Get maximum", 0, 0, "hertz", "Parabolic")  # get max pitch
        else:
            pitch2 = call(voice, "To Pitch (cc)", 0, 50, 15, "yes", 0.03, 0.45, 0.01, 0.35, 0.14, 800)
            pitch2_max_f0: float = call(pitch2, "Get maximum", 0, 0, "hertz", "Parabolic")  # get max pitch

        ceiling: float = pitch2_max_f0 * 1.1
        return ceiling

    # Default generation of the pitch floor
    def pitch_floor(self, voice):
        broad_pitch = call(voice, "To Pitch (cc)", 0, 50, 15, "yes", 0.03, 0.45, 0.01, 0.35, 0.14, 800)
        broad_mean_f0: float = call(broad_pitch, "Get mean", 0, 0, "hertz")  # get mean pitch
        if broad_mean_f0 < 400:
            pitch2 = call(voice, "To Pitch (cc)", 0, 50, 15, "yes", 0.03, 0.45, 0.01, 0.35, 0.14, 500)
            pitch2_min_f0: float = call(pitch2, "Get minimum", 0, 0, "hertz", "Parabolic")  # get min pitch
        else:
            pitch2 = call(voice, "To Pitch (cc)", 0, 50, 15, "yes", 0.03, 0.45, 0.01, 0.35, 0.14, 800)
            pitch2_min_f0: float = call(pitch2, "Get minimum", 0, 0, "hertz", "Parabolic")  # get min pitch

        floor: float = pitch2_min_f0 * 0.9
        return floor