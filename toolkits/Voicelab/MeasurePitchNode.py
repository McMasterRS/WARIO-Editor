from pipeline.Node import Node
from parselmouth.praat import call
from toolkits.Voicelab.VoicelabNode import VoicelabNode

###################################################################################################
# MEASURE PITCH NODE
# WARIO pipeline node for measuring voice pitch.
###################################################################################################
# ARGUMENTS:
# 'voice'   : sound file generated by parselmouth praat
###################################################################################################
# RETURNS:
# 'mean_f0' : mean pitch
# 'stdev_f0': standard deviation
# 'min_f0'  : min pitch value
# 'max_f0'  : max pitch value
###################################################################################################

class MeasurePitchNode(VoicelabNode):

    def __init__(self, *args, **kwargs):

        super().__init__(*args, **kwargs)
        # Default settings for measuring pitch.
        self.args = {

            # Simple default values
            'Time Step': 0,
            'Max Number of Candidates': 15,
            'Silence Threshold': 0.03,
            'Voicing Threshold': 0.45,
            'Octave Cost': 0.01,
            'Octave Jump Cost': 0.35,
            'Voiced Unvoiced Cost': 0.14,
            'Unit': 'Hertz',

            # Tuple defines a discrete set of options, 0 = selected value, 1 = a list of all options
            'Algorithm': ('To Pitch (ac)', ['To Pitch (ac)', 'To Pitch (cc)']),
            'Very Accurate': ('no', ['yes', 'no']),

            # The default setting is to generate these when processing is done.
            'Pitch Ceiling': self.pitch_ceiling,
            'Pitch Floor': self.pitch_floor
            
        }

    def process(self):

        voice = self.args['voice']
        file_duration: float = call(voice, "Get total duration")

        time_step = self.args['Time Step']
        n_max_candidates = self.args['Max Number of Candidates']
        silence_threshold = self.args['Silence Threshold']
        voicing_threshold = self.args['Voicing Threshold']
        octave_cost = self.args['Octave Cost']
        octave_jump_cost = self.args['Octave Jump Cost']
        voiced_unvoiced_cost = self.args['Voiced Unvoiced Cost']
        unit = self.args['Unit']

        algorithm = self.args['Algorithm'][0]
        very_accurate = self.args['Very Accurate'][0]

        pitch_ceiling = self.args['Pitch Ceiling']
        pitch_floor = self.args['Pitch Floor']

        try:
            pitch_ceiling = pitch_ceiling(voice)
        except:
            print('not a function anymore')

        try:
            pitch_floor = pitch_floor(voice)
        except:
            print('not a function anymore')

        pitch = call(
            voice,
            algorithm,
            time_step, 
            pitch_floor,
            n_max_candidates,
            very_accurate,
            silence_threshold,
            voicing_threshold,
            octave_cost,
            octave_jump_cost,
            voiced_unvoiced_cost,
            pitch_ceiling)

        mean_f0: float = call(pitch, "Get mean", 0, 0, self.args['Unit'])
        stdev_f0: float = call(pitch, "Get standard deviation", 0, 0, self.args['Unit'])  # get standard deviation
        min_f0: float = call(pitch, "Get minimum", 0, 0, "hertz", "Parabolic")
        max_f0: float = call(pitch, "Get maximum", 0, 0, "hertz", "Parabolic")

        return {
            'Mean Pitch (F0)': mean_f0,
            'Standard Deviation Pitch (F0)': stdev_f0,
            'Pitch Min (F0)': min_f0,
            'Pitch Max (F0)': max_f0,
            'Pitch': pitch
        }